import sympy as sp
import sympy.physics.mechanics as me
import numpy as np
import scipy
import Animate
from sympy import Dummy
me.init_vprinting()

n = 2

m = sp.symbols('m:{0}'.format(n))                             #Masses
l = sp.symbols('l:{0}'.format(n))                             #Lengths
g = sp.symbols('g')                                           #Gravity
                        
q = me.dynamicsymbols('q:{0}'.format(n))                      #Generalized Coordinates in Configuration Space
qd = me.dynamicsymbols('q:{0}'.format(n), level = 1)          #Vector of the Time Derivatives of the Generalized Coordinates 
u = me.dynamicsymbols('u:{0}'.format(n))                      #Generalized Speeds in Configuration Space
                        
N = me.ReferenceFrame('N')                                    #Inertial Reference Frame
O = me.Point('O')                                             #Coordinate Location in R3
O.set_vel(N, 0)                                               #Sets the Velocity Vector of Point 'O' Relative to Frame 'N'

def get_equations():
    
    ref_frames, kde, particle_loc, particles, gravities, forces, drag = ([] for i in range(7))
      
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    b = 0.3
    for i in range(n):
                
        if i == 0:
            mass_ref_frame = N.orientnew('mass_ref_frame{0}'.format(i), 'Axis', (q[i], N.z))
            ref_frames.append(mass_ref_frame)
            P = O.locatenew('P{0}'.format(i), (-l[i] * ref_frames[i].y))
            Ap = me.Particle('p{0}'.format(i), P, m[i])
        else:
            mass_ref_frame = ref_frames[i-1].orientnew('mass_ref_frame{0}'.format(i), 'Axis', (q[i], N.z))
            ref_frames.append(mass_ref_frame)
            P = particle_loc[i-1].locatenew('P{0}'.format(i), (-l[i] * ref_frames[i].y))
            Ap = me.Particle('p'.format(i), P, m[i])
        particle_loc.append(P)
        particles.append(Ap)
        
    
        vel = u[i]
        subtract = qd[0]
        for j in range(i):
            subtract += qd[j+1]
        kde.append(vel-subtract)
        
        
        drag.append(-b*u[i]*N.y - b*u[i]*N.x - b*u[i]*N.z)
        gravities.append(-g*m[i]*N.y)
        
        forces.append((particle_loc[i], gravities[i] + drag[i]))
           
    
    KM = me.KanesMethod(N, q, u, kd_eqs=kde) # Kane's method instance
    fr, fstar = KM.kanes_equations(particles, forces) # "Evaluate the sum"

    return(KM,-fstar,fr)




def numerical_integration(KM, fstar, fr, times, lengths = None, masses = 1):
    
    
    initial_positions = 120
    initial_velocities = 0
    
    y0 = np.deg2rad(np.concatenate([np.broadcast_to(initial_positions, n),
                                    np.broadcast_to(initial_velocities, n)]))
    
    
    if lengths is None:
        lengths = np.ones(n) / n
    lengths = np.broadcast_to(lengths, n)
    masses = np.broadcast_to(masses, n)
    
    print(y0)
        
    parameters = [g] + list(l) + list(m)
    parameter_vals = [5] + list(lengths) + list(masses)    
    
    unknowns = [Dummy() for i in q + u]
    unknown_dict = dict(zip(q + u, unknowns))
    kds = KM.kindiffdict()
    
    mm_sym = KM.mass_matrix_full.subs(kds).subs(unknown_dict)
    fo_sym = KM.forcing_full.subs(kds).subs(unknown_dict)
    
    mm_func = sp.lambdify(unknowns + parameters, mm_sym)
    fo_func = sp.lambdify(unknowns + parameters, fo_sym)
    
    def gradient(y, t, args):
        vals = np.concatenate((y, args))
        sol = np.linalg.solve(mm_func(*vals), fo_func(*vals))
        return np.array(sol).T[0]
    
    return scipy.integrate.odeint(gradient, y0, times, args=(parameter_vals,))


def get_xy_coords(p, lengths=None):
    """Get (x, y) coordinates from generalized coordinates p"""
    p = np.atleast_2d(p)
    n = p.shape[1] // 2
    if lengths is None:
        lengths = np.ones(n) / n
    zeros = np.zeros(p.shape[0])[:, None]
    x = np.hstack([zeros, lengths * np.sin(p[:, :n])])
    y = np.hstack([zeros, -lengths * np.cos(p[:, :n])])
    return np.cumsum(x, 1), np.cumsum(y, 1)


t = np.arange(0, 10+0.006944444, 0.006944444)

KM,EOM_i,EOM_f = get_equations()
call = numerical_integration(KM,EOM_i,EOM_f,t)
x, y = get_xy_coords(call)
